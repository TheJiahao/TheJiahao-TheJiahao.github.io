---
date: 2025-01-11

title: 使用 React 为 Astro 博客实现动态文章目录
description: 本文介绍了如何为 Astro 博客实现自动高亮当前段落的目录。

draft: true
---

本文将介绍如何为 Astro 博客实现自动高亮当前段落的目录组件。
实现主要分为三步：

1. 将 Astro 的标题对象嵌套
1. 根据可见章节计算当前标题
1. 用 React 实现目录和标题组件

## Astro

### 渲染流程

### 标题处理

## 获取当前标题

### 分隔章节

为了区分可见章节，需要先用 [remark-sectionize](https://www.npmjs.com/package/remark-sectionize) 插件分隔章节。
首先需要安装插件，笔者使用 `pnpm`，但也可以使用 `npm`、`yarn` 或者其他包管理器。

```shell
pnpm add remark-sectionize
```

接着将插件添加到 Astro 设置文件。

```ts title="astro.config.ts"
import remarkSectionize from "remark-sectionize";
import { defineConfig } from "astro/config";

export default defineConfig({
    ...
    remarkPlugins: [remarkSectionize],
})
```

现在，Astro 生成的 HTML 文件中章节会按标题分隔到 `<section/>` 标签内，例如以下 Markdown 内容

```markdown
# 如何实现目录

## 安装插件

...

## React 组件

...
```

会变成：

```html
<section>
    <h1>如何实现目录</h1>
    <section>
        <h2>安装插件</h2>
        <p>...</p>
    </section>
    <section>
        <h2>React 组件</h2>
        <p>...</p>
    </section>
</section>
```

### 检测可见章节

分隔完章节后就可以用浏览器的 [Intersection Observer API](https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API) 检测可见章节和对应的标题。
由于检测可见章节的逻辑比较复杂，笔者选择将其放到 [Hook](https://zh-hans.react.dev/learn/reusing-logic-with-custom-hooks) 里面：

```ts title="useSectionVisibility.ts"
const useSectionVisibility = (id: string): boolean => {
    const [visible, setVisible] = useState<Set<string>>(new Set());
    const [headings, setHeadings] = useState<HTMLHeadingElement[]>([]);

    useEffect(() => {
        const sections = Array.from(
            document.querySelectorAll("article section:not(.footnotes)"),
        );
        const observer = new IntersectionObserver(updateVisibility(setVisible));

        setHeadings(
            sections.map(getHeading).filter((heading) => heading !== null),
        );

        for (const section of sections) {
            observer.observe(section);
        }

        return () => {
            observer.disconnect();
        };
    }, []);

    return id === getCurrentHeading(headings, visible);
};
```

因为 Intersection Observer 每次调用回调函数都需要遍历所有监视的对象，
所以笔者选择分别记录可见标题和所有标题。
这样只需要保证包含所有标题的列表顺序即可。
由于之后判断当前标题时需要快速的检查标题是否可见，可见标题适合用 [Set](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)（散列表）存储。

获取章节标题的逻辑可用很多种方式实现。
本站采用的 [实现方式](https://github.com/TheJiahao/TheJiahao.github.io/blob/124cfcb8bd981c9acc91ae3c30700914a9af9708/src/hooks/useSectionVisibility.ts#L5C1-L13C3) 能限制标题层级，但相对复杂，所以本文仅介绍另一种更简单的实现方式：

```ts title="getHeading.ts"
const getHeading = (section: Element) =>
    section.querySelector<HTMLHeadingElement>("h1,h2,h3");
```

更新可见标题只需要遍历所有章节并添加新的可见标题和删除不可见标题：

```ts title="updateVisibility.ts"
const updateVisibility =
    (
        setVisible: Dispatch<SetStateAction<Set<string>>>,
    ): IntersectionObserverCallback =>
    (entries) => {
        for (const { target, isIntersecting } of entries) {
            const heading = getHeading(target);

            if (!heading) {
                continue;
            }

            if (!isIntersecting) {
                setVisible((current) =>
                    current.difference(new Set([heading.id])),
                );
                continue;
            }

            setVisible((current) => current.union(new Set([heading.id])));
        }
    };
```

### 当前标题

本文中将要高亮的标题称为当前标题。
当前标题可以用不同方式定义，比如可以把所有可见标题都定义为当前标题。
笔者将当前标题定义为从文章开头数第一个层级最深的标题。
例如以下可见标题中当前标题为 “二级标题1” 和 “三级标题1”。

```txt {3}
一级标题1
一级标题2
    二级标题1
```

```txt {3}
一级标题1
    二级标题1
        三级标题1
一级标题2
    二级标题2
        三级标题2
```

```typescript title="getCurrentHeading.ts" collapse={1-4}
const getHeadingDepth = (heading: HTMLHeadingElement): number => {
    return Number(heading.tagName.replace(/h/i, ""));
};

export const getCurrentHeading = (
    headings: HTMLHeadingElement[],
    visibleHeadings: Set<string>,
): string | undefined => {
    let current = null;

    for (const heading of headings) {
        if (!visibleHeadings.has(heading.id)) {
            continue;
        }

        if (!current) {
            current = heading;
            continue;
        }

        if (getHeadingDepth(heading) <= getHeadingDepth(current)) {
            break;
        }

        current = heading;
    }

    return current?.id;
};
```

## React 组件

## 效果
